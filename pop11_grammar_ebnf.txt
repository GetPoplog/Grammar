Grammar ::= Expression

Expression ::= 
	Literal
	| ConstantExpression
	| Variable
	| Assignment
	| Definition
	| Declaration
	| Conditional
	| BooleanExpression
	| Iterative
	| OperatorExpression
	| FunctionApplication
	| Jump
	| Label
	| '(' Sequence ')'

ConstantExpression ::=
	Construct
	| '"' Word '"'

Definition ::=
	'define' Word ('(' Varslist? ')' | Varslist)? ('->' Varslist)* ';' Sequence 'enddefine'

Assignment ::=
	Expression ('->' | '->>') (Variable | FunctionApplication)
	| Expression '-->' Expression

Variable ::=
	Word
	| 'nonop' Operation
	| 'nonmac' Macro
	| 'nonsyntax' SyntaxWord

Declaration ::=
	('global'? ('vars' 'procedure'? | 'constant') Varslist | ('lvars' | 'lconstant' | 'dlocal') (',' | Word)+) ';'

Varslist ::=
	((','* Word?)+ ('macro' | 'syntax' | Number) Word)+

Sequence ::=
	(Expression (',' | ';' | '=>' | '==>'))+

Literal ::=
	Number
	| String
	| '"' String '"'

Construct ::=
	ListConstruct
	| PatternConstruct
	| VectorConstruct

VectorConstruct ::=
	'{' ListSegment* '}'

ListConstruct ::=
	'[' ListSegment* ']'

PatternConstruct ::=
	'[' PatternSegment ']'

ListSegment ::=
	'%' Sequence '%'
	| Word
	| Literal
	| Construct
	| ('^' | '^^') (Word | '(' Sequence ')')

PatternSegment ::=
	ListSegment
	| ('?' | '??') Word (':' (Integer | Word | ListSegment))?
	| '='
	| '=='

Label ::=
	Word ':' '*'?

Jump ::=
	'goto' Word

Iterative ::=
	'for' Expression 'step' Expression 'till' Expression 'do' Sequence 'endfor'
	| 'while' Expression 'do' Sequence 'endwhile'
	| 'until' Expression 'do' Sequence 'enduntil'
	| 'for' Word (('in' | 'on') | ('from' Expression ('by' Expression)?)? 'to') Expression 'do' Sequence 'endfor'
	| 'for' Word 'from_repeater' Expression 'do' Sequence 'endfor'
	| 'foreach' Expression ('in' Expression)? 'do' Sequence 'endforeach'
	| 'forevery' Expression ('in' Expression)? 'do' Sequence 'endforevery'
	| 'repeat' (Expression 'times' | 'forever')? Sequence 'endrepeat'

Conditional ::=
	'if' Expression 'then' Sequence (('elseif' | 'elseunless') Expression 'then' Sequence)* ('else' Expression)? 'endif'
	| 'unless' Expression 'then' Sequence (('elseif' | 'elseunless') Expression 'then' Sequence)* ('else' Expression)? 'endunless'

BooleanExpression ::=
	Expression (('and' | 'or') Expression)*

OperatorExpression ::=
	Expression Operator Expression

FunctionApplication ::=
	Expression '(' Expression? (',' Expression?)* ')'
	| '.' Expression
